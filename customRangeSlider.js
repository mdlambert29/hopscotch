import { c as ne, d as L } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-ZZR72ROS.js";
import { a as be } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-7CAOOJVW.js";
import { b as w, e as U } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-5ZAXQR3N.js";
import { b as te } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-RIUIZ22L.js"; 
import { g as J, h as Q, i as Z, j as ee } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-OF4NI3Y7.js"; 
import "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-7MN7YYBO.js"; 
import { a as B, b as P, c as _, d as X, e as z, f as q, g as G } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-L4B2V5MO.js"; 
import { a as v } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-XGBNL6CO.js"; 
import { b as Y, e as O, f as H, o as $ } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-MSWT7UYR.js"; 
import { a as se } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-XWI3PDH5.js"; 
import { q as j } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-REJ3R5JH.js"; 
import { c as ae } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-GGDEANQW.js"; 
import { c as fe } from "https://cdn.jsdelivr.net/npm/@finsweet/attributes@2/dist/chunk-K46K3RI5.js"; 
var ge = "1.9.0"; 
var me = fe(be(), 1); 
var N = s => s instanceof MouseEvent ? s.clientX : s.touches[0].clientX; var F = ["wrapper", "track", "fill", "handle", "display-value"], W = { min: { key: "min" }, max: { key: "max" }, start: { key: "start" }, step: { key: "step" }, formatdisplay: { key: "formatdisplay", values: ["true"] }, update: { key: "update", values: ["move", "release"], defaultValue: "move" }, lazy: { key: "lazy", values: ["true"] } }, D = [J, Z], ye = [Q, ee], ie = [...D, ...ye]; var { queryElement: C, queryAllElements: T, hasAttributeValue: K, getAttribute: V } = se(j, F, W); 
var re = s => { let e = C("track", { scope: s }), t = C("fill", { scope: s }), a = [...s.querySelectorAll("input")].filter($), n = T("handle", { scope: s }), i = T("display-value", { scope: s }), r = V(s, "formatdisplay"), l = K(s, "update", "release"), o = K(s, "lazy", "true"); if (!n.length || !e) { console.error("The rangeslider is missing a Track element or a Handle element."); return } let { left: c, right: p } = e.getBoundingClientRect(), b = e.clientWidth; e.style.position = "relative"; let h = parseFloat(V(s, "min") || "0"), m = parseFloat(V(s, "max") || `${h + 1}`), d = m - h; if (Number.isNaN(d)) { console.error("Please make sure min and max are numbers."); return } if (Math.sign(d) === -1) { console.error("The min can't be greater than the max."); return } let g = parseFloat(V(s, "step") || `${d / 100}`), f = ne(g); return d % g > 0 && console.warn(`The provided step [${g}] doesn't fit the range [${h},${m}], are you sure you want to use this value?`), { trackElement: e, fillElement: t, handleElements: n, inputElements: a, displayValueElements: i, formatValueDisplay: r, trackLeft: c, trackRight: p, trackWidth: b, minRange: h, maxRange: m, totalRange: d, step: g, precision: f, updateOnRelease: l, isLazy: o } }; var le = (s, [e, t]) => { let a = e.getValue(), n = t?.getValue(), i = ve(s, [a, n]); if (!Y(i)) return; let [r, l] = e.getConstraints(); if (i === a && s >= r && s <= l) return e; if (!t || i !== n) return; let [o, c] = t.getConstraints(); if (s >= o && s <= c) return t }, ve = (s, e) => { let t = e.filter(H); return t.length ? t.reduce((n, i) => Math.abs(i - s) < Math.abs(n - s) ? i : n) : void 0 }; var I = class { constructor(e, { minRange: t, maxRange: a, handles: n, trackWidth: i }) { this.element = e; e.style.position = "absolute", e.style.right = "unset", this.minRange = t, this.totalRange = a - t, this.handles = n, this.trackWidth = i, this.update() } minRange; totalRange; handles; trackWidth; updateTrackWidth(e) { this.trackWidth = e } update() { let { element: e, trackWidth: t, minRange: a, totalRange: n, handles: [i, r] } = this, l, o, c = (i.getValue() - a) * t / n; r ? (l = c, o = (r.getValue() - i.getValue()) * t / n) : (l = 0, o = c), e.style.left = `${l}px`, e.style.width = `${o}px` } }; var oe = (s, e) => { s.setAttribute(B, "slider"), s.setAttribute(P, "0"), ![_, X].some(t => s.getAttribute(t)) && e && s.setAttribute(_, e.name) }; var ue = s => { s.style.position = "absolute", s.style.right = "unset", s.style.top = "50%", s.style.transform = "translate(-50%, -50%)" }; var M = class { constructor(e, { index: t, minRange: a, maxRange: n, trackWidth: i, step: r, precision: l, startValue: o, isLazy: c, inputElement: p, displayValueElement: b, formatValueDisplay: h }) { this.element = e; this.inputElement = p, this.displayValueElement = b, this.formatValueDisplay = h, this.index = t, this.minRange = a, this.maxRange = n, this.totalRange = n - a, this.step = r, this.precision = l, this.minValue = a, this.maxValue = n, this.trackWidth = i, ue(e), oe(e, p), this.setValue(p?.value ? parseFloat(p.value) : o, !c), this.destroy = this.listenEvents() } destroy; index; minRange; maxRange; totalRange; step; precision; inputElement; displayValueElement; formatValueDisplay; fill; sibling; trackWidth; currentValue; minValue; maxValue; updatingInput = !1; listenEvents() { let { element: e, inputElement: t } = this, a = [v(e, "keydown", n => this.handleKeyDown(n)), v(t, "change", () => this.handleInputChange())]; return () => { for (let n of a) n() } } handleKeyDown(e) { let { step: t, currentValue: a } = this, { key: n } = e; ie.includes(n) && (e.preventDefault(), D.includes(n) ? this.setValue(a + t) : this.setValue(a - t)) } handleInputChange() { let { inputElement: e, index: t, minRange: a, maxRange: n, step: i, precision: r, updatingInput: l } = this; if (!e || l) return; let { value: o } = e, c = parseFloat(o); if (c) { this.setValue(L(c, i, r, a)); return } this.setValue(t === 0 ? a : n, !1) } formatValue(e, t) { let a = t === "true" ? void 0 : t; try { return e.toLocaleString(a) } catch { return e.toLocaleString(window.navigator?.language || void 0) } } updatePosition() { let { currentValue: e, element: t, trackWidth: a, minRange: n, totalRange: i, fill: r } = this, l = (e - n) * a / i; t.style.left = `${l}px`, r?.update() } getValue = () => this.currentValue; setValue(e, t = !0) { let { currentValue: a, element: n, minValue: i, maxValue: r, displayValueElement: l, formatValueDisplay: o } = this; if (a === e || e < i || e > r) return !1; this.currentValue = e, this.updatePosition(), this.updateSiblingConstraints(); let c = `${e}`; return n.setAttribute(z, c), l && (l.textContent = o ? this.formatValue(e, o) : c), t && this.updateInputElement(), !0 } updateInputElement() { this.updatingInput = !0; let { currentValue: e, inputElement: t } = this; t && (te(t, e.toFixed(2)), this.updatingInput = !1) } getConstraints = () => [this.minValue, this.maxValue]; setConstraints(e, t) { let { element: a } = this, n = e.toFixed(2), i = t.toFixed(2); a.setAttribute(q, n), a.setAttribute(G, i), this.minValue = Number(n), this.maxValue = Number(i) } updateSiblingConstraints() { let { index: e, sibling: t, step: a, minRange: n, maxRange: i, currentValue: r } = this; t && (e === 0 ? t.setConstraints(r + a, i) : t.setConstraints(n, r - a)) } updateTrackWidth(e) { this.trackWidth = e, this.fill?.updateTrackWidth(e), this.updatePosition() } addFill(e) { this.fill = e } addSibling(e) { this.sibling = e, this.updateSiblingConstraints() } }; var ce = ({ handleElements: s, inputElements: e, displayValueElements: t, formatValueDisplay: a, minRange: n, maxRange: i, trackWidth: r, step: l, precision: o, isLazy: c }) => { let p = s.slice(0, 2).map((m, d) => { let g = parseFloat(V(m, "start") || `${d === 0 ? n : i}`), f = L(g, l, o, n), A = e[d], S = t[d]; return f < n && (console.error(`The Handle start value [${f}] doesn't match the range, so it has been set to the min value [${n}].`), f = n), f > i && (console.error(`The Handle start value [${f}] doesn't match the range, so it has been set to the max value [${i}].`), f = i), new M(m, { index: d, minRange: n, maxRange: i, trackWidth: r, step: l, precision: o, startValue: f, inputElement: A, displayValueElement: S, formatValueDisplay: a, isLazy: c }) }).filter(H); if (!p.length) return; p.length > 1 && p.sort((m, d) => m.getValue() - d.getValue()); let [b, h] = p; return h ? (b.addSibling(h), h.addSibling(b)) : b.setConstraints(n, i), [b, h] }, de = ({ fillElement: s, minRange: e, maxRange: t, trackWidth: a }, n) => { if (!s) return; let i = new I(s, { minRange: e, maxRange: t, trackWidth: a, handles: n }), [r, l] = n; r.addFill(i), l?.addFill(i) }; var Ve = async () => { await ae(); let e = T("wrapper").map(Ae).filter(H); return { result: e.map(({ handles: a }) => a), destroy() { for (let { destroy: a } of e) a() } } }, Ae = s => { let e = re(s); if (!e) return; let t = ce(e); if (!t) return; de(e, t); let { maxRange: a, minRange: n, step: i, precision: r, totalRange: l, trackElement: o, updateOnRelease: c } = e, { trackWidth: p, trackLeft: b, trackRight: h } = e, m, d = !1, g = u => { let E = n + (u - b) * l / p; return L(E, i, r, n) }, f = u => { if (!m) return; u instanceof MouseEvent && u.preventDefault(); let E = N(u), [y, x] = m.getConstraints(), R; b > E ? R = y : h < E ? R = x : R = g(E); let he = m.setValue(R, !c); d ||= he }, A = u => { u.cancelable && u.preventDefault(), document.removeEventListener("mousemove", f), document.removeEventListener("touchmove", f), document.removeEventListener("mouseup", A), document.removeEventListener("touchend", A), c && d && m?.updateInputElement(), d = !1, m?.element.blur(), m = void 0 }, S = u => { u.cancelable && u.preventDefault(); let E = N(u); document.addEventListener("mousemove", f), document.addEventListener("touchmove", f, { passive: !0 }), document.addEventListener("mouseup", A), document.addEventListener("touchend", A); let y; b > E ? y = n : h < E ? y = a : y = g(E); let x = le(y, t); if (!x) return; x.element.focus(), m = x; let R = x.setValue(y, !c); d ||= R }, k = () => { p = o.clientWidth, { left: b, right: h } = o.getBoundingClientRect(); for (let u of t) u && u.updateTrackWidth(p) }, pe = [(() => { let u = U(s); if (!u) return O; let E = new MutationObserver(() => { w(u) && k() }); return E.observe(u, { attributes: !0, attributeFilter: ["style", "class"] }), () => E.disconnect() })(), v(o, "mousedown", S), v(o, "touchstart", S, { passive: !0 }), v(window, "resize", (0, me.default)(k, 50))]; return { handles: t, destroy: () => { for (let u of pe) u() } } }; export { F as ELEMENTS, W as SETTINGS, Ve as init, ge as version };